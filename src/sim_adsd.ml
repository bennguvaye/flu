open Lacaml.D

(* system parameter values *)
let size_r = ref (10. ** 5.)
let r0_r = ref (2.)
let e_r = ref (0.15)
let etaN1_r = ref (10. ** (-7.6))
let etaN2_r = ref (10. ** (-7.6))
let g1_r = ref (1. /. (10. *. 365.))
let g2_r = ref (1. /. (10. *. 365.))
let nu_r = ref (1. /. 2.77)
let q_r = ref (2. /. 365.)

(* Theoretical parameter set *)
(*
let size_r = ref (10. ** 5.)
let r0_r = ref (5.)
let e_r = ref (0.35)
let etaN1_r = ref (10. ** (-.7.))
let etaN2_r = ref (10. ** (-.7.))
let g1_r = ref (1. /. (20. *. 365.))
let g2_r = ref (1. /. (20. *. 365.))
let nu_r = ref (1. /. 8.) 
let q_r = ref (2. /. 365.) 
*)

(* variational system behaviour *)
let init_perturb_r = ref (10. ** (~-. 8.))
let dilat_bound_r = ref 10.

(* simulation arguments *)
let tf_r = ref (365. *. 200.)

(* FIXME initialize all that later in file ? *)
(* FIXME find the right values *)
(* FIXME problem if the user changes one but not the other *)
let m_r = ref 3
let prop_r = ref (Vec.of_array
              [| 0.25 ; 0.54 ; 0.21 |]) (* data for Paris *)

let sensi_r = ref (Vec.of_array
              [| 1. ; 1. ; 1. |]) (* what do we use ? *) 

(* We use as values the Mij.dat generated by age.r even if it's maybe incorrect *)
(* reason why : no conservation of the dominant eigenvalue after transformation *)
let cont_r =
  let cont_r_base = Mat.of_array
              [| 
                [| 13.747 ; 5.037 ; 1.846 |] ;
                [| 5.037  ; 8.665 ; 4.041 |] ; 
                [| 1.846  ; 4.041 ; 7.747 |] 
              |]
  in
  (* We normalize it by its dominant eigenvalue so that the mean number 
   of secondary contacts is 1 *)
  (*
  Mat.scal (1. /. 18.21203416) cont_r_base ;
  *)
  ref cont_r_base

let x0 = Vec.of_array 
           [| 0.2 ; 0.2 ; 0.2 ; 0.2 ;
              0.001 ; 0.001 ; 0.001 ; 0.001 ;
              0.049 ; 0.049 ; 0.049 ; 0.049 |]

(* Algorithm parameters *)
let h0_r = ref (1. /. (24. *. 60.))
let delta_r = ref 0.1
let min_step_r = ref (1. /. (24. *. 3600.))
let max_step_r = ref 1.

let change_chan_to_file co_r s =
  co_r := open_out s

let load_vec_from_file v_r fname =
  let data = Csv.load fname in
  match data with
  | [] -> 
      failwith "no data read from file"
  | l1 :: l2 :: _ -> 
      failwith "file has more than one line"
  | l1 :: [] ->
      let l = List.map (fun s -> float_of_string s) l1 in
      let v = Vec.of_list l in
      v_r := v

let load_mat_from_file m_r fname =
  let data = Csv.load fname in
  match data with
  | [] -> 
      failwith "no data read from file"
  | l1 :: [] -> 
      failwith "file has only one line"
  | l1 :: _ ->
      let ll = List.map 
          (fun l -> List.map (fun s -> float_of_string s) l) data in
      let m = Mat.of_array 
          (Array.of_list (List.map (fun l -> Array.of_list l) ll))
      in m_r := m

let main () =
  let chan_r = ref stdout in
  let specx0 = 
        [Arg.Float (fun x -> x0.{1} <- x);
         Arg.Float (fun x -> x0.{2} <- x);
         Arg.Float (fun x -> x0.{3} <- x);
         Arg.Float (fun x -> x0.{4} <- x);
         Arg.Float (fun x -> x0.{5} <- x);
         Arg.Float (fun x -> x0.{6} <- x);
         Arg.Float (fun x -> x0.{7} <- x);
         Arg.Float (fun x -> x0.{8} <- x);
         Arg.Float (fun x -> x0.{9} <- x);
         Arg.Float (fun x -> x0.{10} <- x);
         Arg.Float (fun x -> x0.{11} <- x);
         Arg.Float (fun x -> x0.{12} <- x)] in
  let specl = 
        [("-dest", Arg.String (change_chan_to_file chan_r),
                ": location of the destination CSV file.\n" ^ 
                "      If not given, outputs to standard output.");
         ("-tf", Arg.Set_float tf_r,
                ": Simulate until (in days)");
         ("-y0", Arg.Tuple specx0,
                ": Initial proportions in each compartment (Should sum to 1)");
         ("-N", Arg.Set_float size_r, 
                ": Total number of hosts in the population");
         ("-R0", Arg.Set_float r0_r, 
                ": Basic reproductive ratio");
         ("-e", Arg.Set_float e_r, 
                ": Strength of the seasonal forcing");
         ("-etaN1", Arg.Set_float etaN1_r, 
                ": Intensity of immigration for strain 1 (per host)");
         ("-etaN2", Arg.Set_float etaN2_r, 
                ": Intensity of immigration for strain 2 (per host)");
         (* it doesn't make sense to use both -etaN and -etaN1 or -etaN2 *)
         ("-etaN", Arg.Float (fun x -> etaN1_r := x; etaN2_r := x),
                ": Intensity of immigration for strains 1 and 2 (per host).");
         ("-g1", Arg.Set_float g1_r, 
                ": Frequency of immunity loss for strain 1 (1/days)");
         ("-g2", Arg.Set_float g2_r, 
                ": Frequency of immunity loss for strain 2 (1/days)");
         (* it doesn't make sense to use both -g and -g1 or -g2 *)
         ("-g", Arg.Float (fun x -> g1_r := x; g2_r := x),
                ": Frequency of immunity loss for strains 1 and 2 (per host).");
         ("-nu", Arg.Set_float nu_r, 
                ": Frequency of recovery from infection (1/days)");
         ("-q", Arg.Set_float q_r, 
                ": Frequency of loss of cross immunity (1/days)");
         ("-m", Arg.Set_int m_r,
                ": Number of age classes (default 3)");
         ("-fprop", Arg.String (load_vec_from_file prop_r),
                " : File location of the proportions of each age class");
         ("-fsensi", Arg.String (load_vec_from_file sensi_r),
                ": File location of the sensibilities for each age class");
         ("-fcont", Arg.String (load_mat_from_file cont_r),
                ": File location of the contact matrix between age classes");
         ("-init_perturb", Arg.Set_float init_perturb_r,
                ": Initial norm (1) of the perturbation");
         ("-dil", Arg.Set_float dilat_bound_r, 
                ": Dilatation factor before rescaling the variational system");
         ("-h0", Arg.Set_float h0_r,
                ": Initial step size");
         ("-delta", Arg.Set_float delta_r,
                ": Maximum tolerated local error. Must be > 0.");
         ("-min_step", Arg.Set_float min_step_r,
                ": Minimum resolution in time. Must be > 0.");
         ("-max_step", Arg.Set_float max_step_r,
                ": Maximum resolution in time. Must be > 0.")]
  in
  (* simply ignore anonymous arguments *)
  let anon_print s = print_endline ("Ignored anonymous argument : " ^ s) in
  (* printed before the help message : *)
  let usage_msg = "  Simulate using Dopri5(.ml) a single strain " ^
                  "seasonally forced SIR model approximating (for example) " ^
                  "influenza dynamics." ^
                  "\nFor more info, look into ssd.mli and dopri5.mli.\n" ^
                  "Available options :" in
  (* parse the command line and update the parameter values *)
  Arg.parse specl anon_print usage_msg ;

  (* sanity check *)
  if not (!m_r = Vec.dim !prop_r) then
    (failwith "Dimensions are not compatible : m and fprop") ;
  if (1. -. 10. ** (~-. !size_r -. 1.)  < Vec.sum ~n:(!m_r) !prop_r) 
  && (Vec.sum ~n:(!m_r)  !prop_r < 1. -. 10. ** (~-. !size_r -. 1.))  then 
    (failwith "The user did not pass a proportion tuple (sums to 1) as fprop : \n") ;
  if (1. -. 10. ** (~-. !size_r -. 1.)  < Vec.sum ~n:12 x0) 
  && (Vec.sum ~n:12 x0 < 1. -. 10. ** (~-. !size_r -. 1.))  then 
    (failwith "The user did not pass a proportion tuple (sums to 1) as x0 : \n") ;
  (* We scale the population size appropriately *)
  scal ~n:12 ~ofsx:1 !size_r x0 ;
  (* We create the perturbation and scale it *)
  let f = fun n -> Random.float 2. -. 1. in
  let rdu = Array.init (12 * !m_r) f in
  let s = Array.fold_left (+.) 0. rdu in
  let dx0 = Vec.of_array (Array.map (fun x -> (x -. s)) rdu) in
  scal ~n:(12 * !m_r) ~ofsx:1 !init_perturb_r dx0 ;
  let y0 = Vec.make0 (12 * 2 * !m_r) in
  for k = 1 to !m_r do
    ignore (copy ~n:12 ~ofsy:(1 + 12 * (k - 1)) ~y:y0 x0) ;
    scal ~n:12 ~ofsx:(1 + 12 * (k - 1)) (!prop_r).{k} y0 
  done ;
  let y0 = copy ~n:(12 * !m_r) ~y:y0 ~ofsy:(1 + 12 * !m_r) dx0 in
  let module Pars = 
    struct
      let size = !size_r
      let r0 = !r0_r
      let e = !e_r
      let etaN1 = !etaN1_r
      let etaN2 = !etaN2_r
      let g1 = !g1_r
      let g2 = !g2_r
      let nu = !nu_r
      let q = !q_r
      let sensi_v = !sensi_r
      let prop_v = !prop_r
      let cont_m = !cont_r
      let init_perturb = !init_perturb_r
      let dilat_bound = !dilat_bound_r
    end
  in
  let module AdsdSys = Adsd.Sys (Pars) in
  let module Algp =
    struct
      let h0 = !h0_r
      let delta = !delta_r
      let min_step = !min_step_r
      let max_step = !max_step_r
    end
  in
  let module Gen = Dopri5.Integrator (AdsdSys) (Algp) in
  Gen.simulate !chan_r !tf_r y0

let () = ignore (main ())
